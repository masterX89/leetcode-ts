const MOD = 998244353
const MOD_CUT = ((1 << 20) * (1 << 20)) % MOD
function add(a, b) {
  return (a + b) % MOD
}
function minus(a, b) {
  return add(add(a, -b), MOD)
}
function mul(a, b) {
  let r = (a >> 20) * (b >> 20) * MOD_CUT
    + (a & 0xFFF00000) * (b & 0xFFFFF)
    + (a & 0xFFFFF) * b
  return r % MOD
}
function pow(a, b) {
  let r = 1
  let base = a
  while (b) {
    if (b & 1) {
      r = mul(r, base)
    }
    b >>= 1 // change to divide if b > 1e9 !!
    base = mul(base, base)
  }
  return r
}

class priorityQueue {
  constructor() {
    this.a = []
  }

  push(num, inc) {
    const a = this.a
    for (var i = a.length, j; i; i = j) {
      j = i - 1 >> 1
      if (a[j][0] <= num)
        break
      a[i] = a[j]
    }
    a[i] = [num, inc]
  }

  pop() {
    const a = this.a; const r = a[0]; const x = a.pop(); const k = a.length >> 1
    for (var i = 0, j; i < k; i = j) {
      j = (i << 1) + 1
      if (a[j + 1] && a[j + 1][0] < a[j][0])
        j++
      if (x[0] <= a[j][0])
        break
      a[i] = a[j]
    }
    if (a.length)
      a[i] = x
    return r
  }

  pushpop(num, inc) {
    const a = this.a; const r = a[0]; const k = a.length >> 1
    if (!a.length || r[0] >= num)
      return [num, inc]
    for (var i = 0, j; i < k; i = j) {
      j = (i << 1) + 1
      if (a[j + 1] && a[j + 1][0] < a[j][0])
        j++
      if (num <= a[j][0])
        break
      a[i] = a[j]
    }
    a[i] = [num, inc]
    return r
  }

  poppush(num, inc) {
    const a = this.a; const r = a[0]; const k = a.length >> 1
    for (var i = 0, j; i < k; i = j) {
      j = (i << 1) + 1
      if (a[j + 1] && a[j + 1][0] < a[j][0])
        j++
      if (num <= a[j][0])
        break
      a[i] = a[j]
    }
    a[i] = [num, inc]
    return r
  }

  get size() {
    return this.a.length
  }

  get top() {
    return this.a[0]
  }
}

// Generated by CoffeeScript 1.8.0
;(function () {
  let Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup

  floor = Math.floor, min = Math.min

  /*
  Default comparison function to be used
   */

  defaultCmp = function (x, y) {
    if (x < y) {
      return -1
    }
    if (x > y) {
      return 1
    }
    return 0
  }

  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.

  If x is already in a, insert it to the right of the rightmost x.

  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function (a, x, lo, hi, cmp) {
    let mid
    if (lo == null) {
      lo = 0
    }
    if (cmp == null) {
      cmp = defaultCmp
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative')
    }
    if (hi == null) {
      hi = a.length
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2)
      if (cmp(x, a[mid]) < 0) {
        hi = mid
      }
      else {
        lo = mid + 1
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x)
  }

  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function (array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp
    }
    array.push(item)
    return _siftdown(array, 0, array.length - 1, cmp)
  }

  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function (array, cmp) {
    let lastelt, returnitem
    if (cmp == null) {
      cmp = defaultCmp
    }
    lastelt = array.pop()
    if (array.length) {
      returnitem = array[0]
      array[0] = lastelt
      _siftup(array, 0, cmp)
    }
    else {
      returnitem = lastelt
    }
    return returnitem
  }

  /*
  Pop and return the current smallest value, and add the new item.

  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function (array, item, cmp) {
    let returnitem
    if (cmp == null) {
      cmp = defaultCmp
    }
    returnitem = array[0]
    array[0] = item
    _siftup(array, 0, cmp)
    return returnitem
  }

  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function (array, item, cmp) {
    let _ref
    if (cmp == null) {
      cmp = defaultCmp
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1]
      _siftup(array, 0, cmp)
    }
    return item
  }

  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function (array, cmp) {
    let i, _i, _j, _len, _ref, _ref1, _results, _results1
    if (cmp == null) {
      cmp = defaultCmp
    }
    _ref1 = (function () {
      _results1 = []
      for (let _j = 0, _ref = floor(array.length / 2); _ref >= 0 ? _j < _ref : _j > _ref; _ref >= 0 ? _j++ : _j--) { _results1.push(_j) }
      return _results1
    }.apply(this)).reverse()
    _results = []
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i]
      _results.push(_siftup(array, i, cmp))
    }
    return _results
  }

  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function (array, item, cmp) {
    let pos
    if (cmp == null) {
      cmp = defaultCmp
    }
    pos = array.indexOf(item)
    if (pos === -1) {
      return
    }
    _siftdown(array, 0, pos, cmp)
    return _siftup(array, pos, cmp)
  }

  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function (array, n, cmp) {
    let elem, result, _i, _len, _ref
    if (cmp == null) {
      cmp = defaultCmp
    }
    result = array.slice(0, n)
    if (!result.length) {
      return result
    }
    heapify(result, cmp)
    _ref = array.slice(n)
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i]
      heappushpop(result, elem, cmp)
    }
    return result.sort(cmp).reverse()
  }

  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function (array, n, cmp) {
    let elem, i, los, result, _i, _j, _len, _ref, _ref1, _results
    if (cmp == null) {
      cmp = defaultCmp
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp)
      if (!result.length) {
        return result
      }
      los = result[result.length - 1]
      _ref = array.slice(n)
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i]
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp)
          result.pop()
          los = result[result.length - 1]
        }
      }
      return result
    }
    heapify(array, cmp)
    _results = []
    for (i = _j = 0, _ref1 = min(n, array.length); _ref1 >= 0 ? _j < _ref1 : _j > _ref1; i = _ref1 >= 0 ? ++_j : --_j) {
      _results.push(heappop(array, cmp))
    }
    return _results
  }

  _siftdown = function (array, startpos, pos, cmp) {
    let newitem, parent, parentpos
    if (cmp == null) {
      cmp = defaultCmp
    }
    newitem = array[pos]
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1
      parent = array[parentpos]
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent
        pos = parentpos
        continue
      }
      break
    }
    return array[pos] = newitem
  }

  _siftup = function (array, pos, cmp) {
    let childpos, endpos, newitem, rightpos, startpos
    if (cmp == null) {
      cmp = defaultCmp
    }
    endpos = array.length
    startpos = pos
    newitem = array[pos]
    childpos = 2 * pos + 1
    while (childpos < endpos) {
      rightpos = childpos + 1
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos
      }
      array[pos] = array[childpos]
      pos = childpos
      childpos = 2 * pos + 1
    }
    array[pos] = newitem
    return _siftdown(array, startpos, pos, cmp)
  }

  Heap = (function () {
    Heap.push = heappush

    Heap.pop = heappop

    Heap.replace = heapreplace

    Heap.pushpop = heappushpop

    Heap.heapify = heapify

    Heap.updateItem = updateItem

    Heap.nlargest = nlargest

    Heap.nsmallest = nsmallest

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp
      this.nodes = []
    }

    Heap.prototype.push = function (x) {
      return heappush(this.nodes, x, this.cmp)
    }

    Heap.prototype.pop = function () {
      return heappop(this.nodes, this.cmp)
    }

    Heap.prototype.peek = function () {
      return this.nodes[0]
    }

    Heap.prototype.contains = function (x) {
      return this.nodes.includes(x)
    }

    Heap.prototype.replace = function (x) {
      return heapreplace(this.nodes, x, this.cmp)
    }

    Heap.prototype.pushpop = function (x) {
      return heappushpop(this.nodes, x, this.cmp)
    }

    Heap.prototype.heapify = function () {
      return heapify(this.nodes, this.cmp)
    }

    Heap.prototype.updateItem = function (x) {
      return updateItem(this.nodes, x, this.cmp)
    }

    Heap.prototype.clear = function () {
      return this.nodes = []
    }

    Heap.prototype.empty = function () {
      return this.nodes.length === 0
    }

    Heap.prototype.size = function () {
      return this.nodes.length
    }

    Heap.prototype.clone = function () {
      let heap
      heap = new Heap()
      heap.nodes = this.nodes.slice(0)
      return heap
    }

    Heap.prototype.toArray = function () {
      return this.nodes.slice(0)
    }

    Heap.prototype.insert = Heap.prototype.push

    Heap.prototype.top = Heap.prototype.peek

    Heap.prototype.front = Heap.prototype.peek

    Heap.prototype.has = Heap.prototype.contains

    Heap.prototype.copy = Heap.prototype.clone

    return Heap
  })();

  (function (root, factory) {
    // if (typeof define === 'function' && define.amd) {
    //   return define([], factory);
    // } else if (typeof exports === 'object') {
    //   return module.exports = factory();
    // } else {
    return root.Heap = factory()
    // }
  })(this, () => {
    return Heap
  })
}).call(this)
const Heap = this.Heap

function main(stdin) {
  // eslint-disable-next-line unused-imports/no-unused-vars, no-unused-vars
  const { next, nextstr, nextbig, nexts, nextssort, nextm, xArray } = makeInputReader(stdin)
  const [n, q] = nexts(2)
}
function makeInputReader(input) {
  const cin = input.trim().split(/ |\n/)
  let cid = 0
  function createNDArray(shape, fillVal) {
    if (shape.length === 0)
      return fillVal
    const [dim, ...rest] = shape
    return Array.from({ length: dim }, () => createNDArray(rest, fillVal))
  }
  return {
    next: () => Number(cin[cid++]),
    nextstr: () => cin[cid++],
    nextbig: () => BigInt(cin[cid++]),
    nexts: (n, parse = true) =>
      parse ? cin.slice(cid, cid += n).map(Number) : cin.slice(cid, cid += n),
    nextssort: (n, parse = true, desc = false) =>
      parse
        ? cin.slice(cid, cid += n).map(Number).sort((a, b) => desc ? b - a : a - b)
        : cin.slice(cid, cid += n).sort((a, b) => desc ? b.localeCompare(a) : a.localeCompare(b)),
    nextm: (h, w, parse = true) => {
      const res = []
      for (let i = 0; i < h; i++) {
        const row = cin.slice(cid, cid += w)
        res.push(parse ? row.map(Number) : row)
      }
      return res
    },
    xArray: createNDArray,
  }
}

if (require.main === module) {
  const fs = require('node:fs')
  const input = fs.readFileSync('/dev/stdin', 'utf8')
  console.log(main(input))
}

module.exports = { main }
